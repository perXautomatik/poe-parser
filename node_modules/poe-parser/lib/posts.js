var request = require("request");
var jsdom = require("jsdom");
var process = require("process");

var localdate = require("./localdate");
var thread = require("./thread");

var jquery = ["http://code.jquery.com/jquery.js"];

/*
* Db operations section
* @return uint - unix timestamp
*/
function getLastUpdateTime() {}

/*
* Posts parser section
*/

function getThreadTitle(childNode) {
	return childNode.nextSibling.firstChild.innerHTML;
}

function getThreadUrl(uri, childNode) {
	return uri + childNode.nextSibling.firstChild.href;
}

/*
* Transform human readable time format to unix timestamp
*/
function getThreadTime(childNode) {
	var dt,
		month,
		date_str = childNode.lastChild.innderHTML;

	dt = new Date(date_str);
	if (dt.getTime() !== NaN) {
		return dt.getTime();
	}

	/* Another lang rules */
	return localdate.parseByLang(date_str).getTime();
}

/*
* Algorithm theory or how it work:
* Step one - send request to forum page for
* getting bumbed threads info by index @index;
* Step two - parse result body with jsdom.
* Step three - iterate for all founded threads,
* where bumbed time more than lastBumbedTime, stored in database
* And step four - send all threads uri to thread parser.
* 
*/
function parseForumThreads(tradeForum, index, pagesCount, lastBumpTime, outList) {
	var i,
		items,
		node,
		jq,
		obj,
		doneCb,
		parseNext = false;
		url = [tradeForum, "/page/", index].join('');

	index += 1;

	doneCb = function (window) {
		jq = window.$;

		items = jq(".thread");
		for (i = 0; i < items.length; i += 1) {
			node = items[i];

			/* Parse thread information */
			outList.push({
				name: getThreadTitle(node.firstChild),
				url: getThreadUrl(this.baseUri, node.firstChild),
				bumpTime: getThreadTime(node.lastChild)
			});

			if (outList[-1].bumpTime >= lastBumpTime) {
				parseNext = false;
				break;
			} else {
				parseNext = true;
			}

		}

		/*
		* delete all links to in-memory jsdom objects
		*/
		items = null;
		doneCb = null;
		jq = null;
		node = null;
		url = null;

		/* If last bump more than db value or current index == pages count,
		* then parser will be stopped.
		*/
		parseNext &= (index <= pagesCount);

		/*
		* parse all bumped threads on page
		*/
		if (outList.length > 0) {

			/*
			* We should save current boolean result 
			* if call stack be destroyed
			*/
			(function (isNext) {

				thread.parseThreadsList(
					outList,
					/* Call this function when threads parser finished its work */
					function () {
						if (isNext) {
							process.nextTick(function () {
								parseForumThreads.apply(null, arguments);
							});
						}
					},
					arguments
				);

			}(parseNext));
		}
	};


	request.url(url, function(err, response, body) {
		jsdom.env(
			body,
			jquery,
			doneCb
		);
	});
}

/*
* @param tradeSection string
* @param pagesCount int
*/
function searchForLastStoredThread(tradeSection, pagesCount) {
	var lastUpdate = getLastUpdateTime(),
		list = [];

	/* Start process */
	parseForumThreads.call(this, tradeSection, 0, pagesCount, lastUpdate, list);
}

/*
* Path of exile forums structure
* div[class=pagination] - top
*     a - first page
*     ...
*     a - last page
*     a - next page
*
* div[class=pagination]  bottom
*     a - first page
*     ...
*     a - last page
*     a - next page
*/
function getPagesCount(jQuery) {
	try{
		return parseInt(jQuery(".pagination").first()
							.find("a").last().prev().html(), 10);
	} catch (e) {
		return 1;
	}
}

/*
* If you want init simple parser - give as argument trade section.
* @param trade_section string - path of exile url,
* linked to one from any trade league sections (standart, hardcore, etc)
*/
exports.indexPosts = function(tradeSection) {
	var postsList,
		baseUri = thread.getBaseUrl(tradeSection);
		pagesCount;

	request.url(tradeSection, function(err, response, body) {
		if (err || response.statusCode === 200) {
			return 0;
		}

		jsdom.env(
			body,
			jquery,
			function(errors, window) {

				window.$.baseUri = baseUri;
				pagesCount = getPagesCount(window.$);

				/* Init parser */
				searchForLastStoredThread.call(window.$, tradeSection, pagesCount);
			}
		);
	});

};
