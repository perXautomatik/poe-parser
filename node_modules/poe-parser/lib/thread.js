var request = require("request");
var jsdom = require("jsdom");
var process = require("process");
var url = require("url");

var priceNames = ["~b/o", "~c/o"];
var itemModRe = /[0-9]+/g;
var jquery = ["http://code.jquery.com/jquery.js"];

/* Custom errors constants */
var CHARNAME_NOT_FOUND = "unnamed";

function getBaseUrl(uri) {
	var obj = url.parse(uri),
		result;

	return result = [
		obj.protocol,
		(obj.slashes) ? "//" : "",
		obj.host,
		"/"
	].join('');
}

function getProfileUrl(profileLinkNode) {
	return profileLinkNode.nextSibling.href.slice(1);
}

/* Interaction with database */
function checkModAndInsert(index, modObj) {}

function initSaveThreadProc(threadJson, threadInfo) {}

/*
* Preparing json of item for insert to database.
* Updating default raw data more usable for search structure.
* @param mods_list is out param
*/
function parseMods(mods_list) {
	var i,
		mod;

	for (i = 0; i < mods_list.length; i += 1) {
		mod = mods_list[i];
		mods_list[i] = {
			val: mod.match(itemModRe),
			base: mod.replace(itemModRe, "#")
		};
		checkModAndInsert(i, mods_list[i]);
	}
}

function collectItemMods(item) {

	if (item.implicitMods !== undefined) {
		parseMods(item.implicitMods);
	}

	if (item.explicitMods !== undefined) {
		parseMods(item.explicitMods);
	}

}

/* Can use default DOM api */
function getItemPrice(node) {
	return node.nextSibling.innerHTML;
}

function hasPrice(text) {
	if (text === undefined && text === null) {
		return false;
	}

	if (text.length < 4) {
		return false;
	}

	var i,
		has = false;

	for (i = 0; i < priceNames.length; i += 1) {
		if (text.indexOf(priceNames[i]) > -1) {
			has = true;
			break;
		}
	}

	return has;
}

function getThreadSource(scripts) {
	var i,
		raw_data,
		result;

	for (i = 0; i < scripts.length; i += 1) {
		if (scripts[i].text !== undefined && scripts[i].text !== null) {

			raw_data = scripts[i].text.split("function(R) { (new R(");
			if (raw_data.length > 1) {
				break;
			}

		}
	}

	raw_data = raw_data[1].split(")).run")[0];

	return JSON.parse (raw_data);
}

/*
* We looking for IGN in user profile.
* @param html string - profile page in any poe local site by GGG.
*/
function getCharName(html) {
	var keyClass,
		startIndex,
		charInfo,
		endIndex;

	try {
		keyClass = "characterName";
		startIndex = html.indexOf(keyClass);
		charInfo = html.slice(startIndex, startIndex + 200);
		endIndex = charInfo.indexOf("</");

		return charInfo.slice(keyClass.length + 2, endIndex);
	} catch (e) {
		return CHARNAME_NOT_FOUND;
	}
}

/*
* Collect item prices, user active IGN, item sockets, etc
* @param jQuery - dom object for one thread
*/
function buildThread(jQuery, threadInfo) {
	var i,
		postContent,
		source,
		items,
		text,
		profileUrl,
		charName = undefined,
		prices = [];

	postContent = jQuery(".content").first();
	items = postContent.find(".itemContentLayout");

	for (i = 0; i < items.length; i += 1) {
		text = getItemPrice(items.get(i));
		if (hasPrice(text)) {
			prices.push(text);
		} else {
			prices.push(null);
		}
	}

	source = getThreadSource(jQuery("script"));

	for (i = 0; i < prices.length; i += 1) {
		source[i][1].price = prices[i];

		collectItemMods(source[i][1]);
	}

	profileUrl = getBaseUrl(threadInfo.url) + getProfileUrl(jQuery('.profile-link')[0]);


	request.url(profileUrl, function (error, response, body) {
		if (error || response.statusCode !== 200) {
			return 0;
		}

		if (charName === undefined) {
			charName = getCharName(body);
		}

		source.charName = charName;
		initSaveThreadProc(source, threadInfo);
	});
}

/*
* @param done_func function (response, content) { ... }
*/
exports.parseThread = function(url, doneCb, threadInfo) {
	request(url, function(error, response, body) {
		if (error || response.statusCode !== 200) {
			return 0;
		}

		jsdom.env(
			body,
			jquery,
			function (errors, window) {
				buildThread(window.$, threadInfo);

				if (doneCb !== undefined && doneCb !== null) {
					doneCb ();
				}
			}
		);

	});

	return 0;
};

exports.parseThreadsList = function (list, doneCb, doneCbArgs) {
	var thread,
		count = list.length,

		doneThreadCb = function () {
			count = list.length;

			if (count === 0) {
				doneCb.apply(null, doneCbArgs);
			} else {
				thread = list.pop();

				/* Call stack with process api may be free */
				process.nextTick(function () {
					parseThread(thread.url, doneThreadCb, thread);
				});
			}
		};

		doneThreadCb();
};

exports.getBaseUrl = getBaseUrl;
