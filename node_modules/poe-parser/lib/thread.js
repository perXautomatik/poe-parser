var request = require("request");
var jsdom = require("jsdom");

var priceNames = ["~b/o", "~c/o"];
var itemModRe = /[0-9]+/g;
var jquery = ["http://code.jquery.com/jquery.js"];

/* Interaction with database */
function checkModAndInsert(index, modObj) {}

function initSaveThreadProc(threadJson) {}

/*
* Preparing json of item for insert to database.
* Updating default raw data more usable for search structure.
* @param mods_list is out param
*/
function parseMods(mods_list) {
	var i,
		mod;

	for (i = 0; i < mods_list.length; i += 1) {
		mod = mods_list[i];
		mods_list[i] = {
			val: mod.match(itemModRe),
			base: mod.replace(itemModRe, "#")
		};
		checkModAndInsert(i, mods_list[i]);
	}
}

function collectItemMods(item) {

	if (item.implicitMods !== undefined) {
		parseMods(item.implicitMods);
	}

	if (item.explicitMods !== undefined) {
		parseMods(item.explicitMods);
	}

}

/* Can use default DOM api */
function getItemPrice(node) {
	return node.nextSibling.innerHTML;
}

function hasPrice(text) {
	if (text === undefined && text === null) {
		return false;
	}

	if (text.length < 4) {
		return false;
	}

	var i,
		has = false;

	for (i = 0; i < priceNames.length; i += 1) {
		if (text.indexOf(priceNames[i]) > -1) {
			has = true;
			break;
		}
	}

	return has;
}

function getThreadSource(scripts) {
	var i,
		raw_data,
		result;

	for (i = 0; i < scripts.length; i += 1) {
		if (scripts[i].text !== undefined && scripts[i].text !== null) {

			raw_data = scripts[i].text.split("function(R) { (new R(");
			if (raw_data.length > 1) {
				break;
			}

		}
	}

	raw_data = raw_data[1].split(")).run")[0];

	return JSON.parse (raw_data);
}

function buildThread(jQuery) {
	var i,
		postContent,
		source,
		items,
		text,
		prices = [];

	postContent = jQuery(".content").first();
	items = postContent.find(".itemContentLayout");

	for (i = 0; i < items.length; i += 1) {
		text = getItemPrice(items.get(i));
		if (hasPrice(text)) {
			prices.push(text);
		} else {
			prices.push(null);
		}
	}

	source = getThreadSource(jQuery("script"));

	for (i = 0; i < prices.length; i += 1) {
		source[i][1].price = prices[i];

		collectItemMods(source[i][1]);
	}

	initSaveThreadProc(source);
}

/*
* @param done_func function (response, content) { ... }
*/
exports.parseThread = function(url, done_func) {
	var content;

	request(url, function(error, response, body) {
		if (error || response.statusCode !== 200) {
			return 0;
		}

		jsdom.env(
			body,
			jquery,
			function (errors, window) {
				content = buildThread(window.$);

				if (done_func !== undefined && done_func !== null) {
					done_func (response, content);
				}
			}
		);

	});

	return 0;
};

exports.parseThreadsList = function (list, doneCb, doneCbArgs) {

};
